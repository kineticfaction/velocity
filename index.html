<!doctype html>
<html>
  <head>
  		<meta charset="utf-8">
		<title>Game</title>
		<style>
			body {
				background-color: #333;
			}
			#container {
				background-color: black;
				width: 800px;
				height: 450px;
				margin: auto;
				align: center;
			}
		</style>
		<script src='./js/Three.js'></script>
		<script src='./js/velocity.observable.js'></script>
	</head>
	<body>
		<div id="container"></div>
		<script>
			// shim layer with setTimeout fallback
			window.requestAnimFrame = (function(){
				return	window.requestAnimationFrame		||
						window.webkitRequestAnimationFrame	||
						window.mozRequestAnimationFrame		||
						function( callback ){
							window.setTimeout(callback, 1000 / 60);
						};
			})();

			var constants = {
				scene: {
					width: 800,
					height: 450
				},
				camera: {
					fov: 45,
					near: 0.1,
					far: 1000
				}
			}

			var container = document.getElementById("container");

			// create a WebGL renderer, camera
			// and a scene
			var renderer = new THREE.WebGLRenderer();
			var camera = new THREE.PerspectiveCamera(
				constants.camera.fov,
				constants.scene.width / constants.scene.height,
				constants.camera.near,
				constants.camera.far
			);
			var scene = new THREE.Scene();

			// the camera starts at 0,0,0 so pull it back
			camera.position.z = 400;
			camera.position.y = 0;
			camera.rotation.x = 0;

			// start the renderer
			renderer.setSize(
				constants.scene.width, 
				constants.scene.height
			);

			// attach the render-supplied DOM element
			container.appendChild(renderer.domElement);

			// create the sphere's material
			var sphereMaterial = new THREE.MeshLambertMaterial({
				color: 0xCCCCCC
			});

			// create a new mesh with sphere geometry -
			// we will cover the sphereMaterial next!

			var cube1 = new THREE.Mesh(
				new THREE.CubeGeometry(50,20,20), 
				sphereMaterial
			);

			var cube2 = new THREE.Mesh(
				new THREE.CubeGeometry(50,20,20), 
				sphereMaterial
			);

			var cube3 = new THREE.Mesh(
				new THREE.CubeGeometry(50,20,20), 
				sphereMaterial
			);

			scene.add(camera);
			scene.add(cube1);
			scene.add(cube2);
			scene.add(cube3);

			cube1.position.y = -20;
			cube2.position.y = -60;
			cube3.position.y = -100;

			// create a point light
			var lights = []

			lights[0] = new THREE.PointLight( 0xFF3333 );
			lights[1] = new THREE.PointLight( 0x33FF33 );
			lights[2] = new THREE.PointLight( 0x3333FF );


			// set its position
			lights[0].position.x = 10;
			lights[0].position.y = 50;
			lights[0].position.z = 130;

			// set its position
			lights[1].position.x = -100;
			lights[1].position.y = -50;
			lights[1].position.z = 130;

			// set its position
			lights[2].position.x = 100;
			lights[2].position.y = 50;
			lights[2].position.z = -130;

			// add to the scene
			scene.add(lights[0]);
			scene.add(lights[1]);
			scene.add(lights[2]);


			//var keyboard = new THREEx.KeyboardState();

			var havePointerLock = 'pointerLockElement' in document ||
				'mozPointerLockElement' in document ||
				'webkitPointerLockElement' in document;

			if(havePointerLock) {

				container.addEventListener('click', function() {

					container.requestPointerLock = container.requestPointerLock ||
						container.mozRequestPointerLock ||
						container.webkitRequestPointerLock;

					// Ask the browser to lock the pointer
					container.requestPointerLock();

					container.addEventListener('mousemove', function(e) {
						movementX = 	e.movementX       ||
										e.mozMovementX    ||
				  						e.webkitMovementX ||
				  						0,
						movementY = 	e.movementY       ||
				  						e.mozMovementY    ||
				  						e.webkitMovementY ||
				  						0;
					}, false);

					// Ask the browser to release the pointer
					document.exitPointerLock = document.exitPointerLock ||
						document.mozExitPointerLock ||
						document.webkitExitPointerLock;
					document.exitPointerLock();

				}, false);

			}

			var movementX = 0;
			var movementY = 0;



			var updateLights = function() {
				lights[0].position.x = lights[0].position.x + 1;
				lights[1].position.y = lights[1].position.y + 1;
				lights[2].position.z = lights[2].position.z + 1;
			}



			var updatePlayer = function() {
				if(movementX > 10) { movementX = 10; }
				if(movementX < -10) { movementX = -10; }
				camera.rotation.y += movementX / 500;
				movementX = 0;

				if(movementY > 10) { movementY = 10; }
				if(movementY < -10) { movementY = -10; }
				camera.rotation.x += movementY / 2500;
				movementY = 0;
			}

			var Update = new Observable();
			Update.subscribe(updatePlayer);
			Update.subscribe(updateLights);

			function render() {
				renderer.render(scene, camera);
			}
			

			// draw!
			(function animloop(){
				requestAnimFrame(animloop);
				Update.notify(0);
				render();
			})();


		</script>
	</body>
</html>